\section{Preliminaries and Definitions}

\label{sec:preliminaries}

We first define some notation and the terminology used throughout the
rest of the paper.
$h(n)$ denotes the estimate of the cost from the current node $n$ to the nearest goal node.
$g(n)$ is the current shortest known path cost from the initial node to the current node.
$f(n)=g(n)+h(n)$ is the estimate of the resulting cost of the path to a goal
containing the current node.
We omit the argument $(n)$ unless necessary.

\emph{Open-Closed List} (OCL) algorithm \cite{Valenzano2016} is a generalization of \astar, Dijkstra \cite{dijkstra1959note}, GBFS and other graph algorithms.
It is built upon two sets, OPEN and CLOSED, where unexpanded nodes are stored in OPEN and expanded nodes are stored in CLOSED. When operations pop$(S)$, push$(n,S)$, remove$(n,S)$ is defined for a node $n$ and a set $S$, OCL algorithm is defined in \refalgo{alg:ocl}.

\begin{algorithm}                      
\begin{algorithmic}
 \REQUIRE $s_0$, $\text{is\_goal}(\cdot)$, $\text{successors}(\cdot)$ %, strategy
 \STATE Initialize $\text{OPEN}=\emptyset$, $\text{CLOSE}=\emptyset$, $g(s_0)=0$, $\forall s\not=s_0; g(s)=\infty$
 % \STATE \textbf{Local procedure} $\text{open}(s,t,g_{new})$: $g(t) \leftarrow g_{new}$; $\text{parent}(t) \leftarrow s$; $\text{push}(t,\text{OPEN})$
 \STATE $\text{push}(s_0,\text{OPEN})$
 \WHILE{OPEN $\not = \emptyset$}
 \STATE $s = \text{pop}(\text{OPEN}); \text{push}(s,\text{CLOSE})$
 \RETURN $s$ \  \textbf{if} \  $\text{is\_goal}(s)=\text{true}$
 \FORALL{$t \in \text{successors}(s)$}
 \STATE $g_{new} = g(s) + \text{cost}(s,t)$
 \IF{$g_{new} < g(t)$}
 % \STATE $\text{open}(s,t,g_{new})$
 % \STATE $\text{remove}(t,\text{CLOSE})$ 
 % \STATE $\text{CLOSE} \leftarrow \text{CLOSE} \setminus \braces{t}$ 
 \STATE $g(t) \leftarrow g_{new}$;\; $\text{parent}(t) \leftarrow s$;\; $\text{push}(t,\text{OPEN})$;\; $\text{remove}(t,\text{CLOSE})$
 \ENDIF
 \ENDFOR
 \ENDWHILE
\end{algorithmic}
\caption{OCL Algorithm}
\label{alg:ocl}
\end{algorithm}

\emph{Best First Search} (BFS) is a subclass of OCL algorithms where OPEN is sorted according to a \emph{sorting strategy} and pop$(S)$ operation tries to select a single node from the OPEN list following the strategy.
Each sorting strategy is denoted as a vector of several \emph{sorting criteria}, such as
[$\text{criterion}_1$, $\text{criterion}_2$, $\ldots$,
$\text{criterion}_k$], which defines a lexicographic ordering ---
i.e., from the OPEN list, first, select a
set of nodes using $\text{criterion}_1$, and if there are still multiple
nodes remaining in the set, then break ties using $\text{criterion}_2$
and so on, until a single node is selected.  The \emph{first-level
sorting criterion} of a strategy is $\text{criterion}_1$, the
\emph{second-level sorting criterion} is $\text{criterion}_2$, and so on.
%% the word frontier is no longer used in the later text.
% \emph{final frontier} is the set of open nodes with $f^*$.
Note that this corresponds to the command line option format of Fast
Downward \cite{Helmert2006}.

Using this notation, \astar without any tie-breaking strategy can be
denoted as a BFS with $[f]$, and \astar which breaks ties according to $h$
value is denoted as $[f,h]$.
% Similarly, GBFS is denoted as $[h]$.
Unless stated otherwise, we assume the nodes are sorted in the
increasing order of the key value, and a BFS always selects the smallest
key value.

However, a sorting strategy may only provide a partial ordering ---
i.e., the sorting strategy may fail to select a single node because some nodes
may share the same sorting keys.
For such cases, a BFS algorithm must
decide which node to expand by a \emph{default} tie-breaking
criterion $\text{criterion}_k$ such as  \fifo (oldest node first: first-in-first-out), \lifo
(most recently inserted first: last-in-first-out) or \ro (random ordering).
For example, an \astar using $h$ tie-breaking and \fifo default tie-breaking
 is denoted as $[f,h,\fifo]$.
By definition, there is only 1 node which satisfies the default criterion, so
strategies with a default criterion guarantee the total order and
are able to select a single node from the set of nodes.
When the default criterion is irrelevant to the discussion,
we use a wildcard * e.g. $[f,h,*]$ or sometimes omit it.

Given a search algorithm with a sorting strategy, 
a $\plateau{\text{criterion}\ldots}$ is a set of nodes in OPEN whose elements share
the same sort keys according to non-default sorting criteria and therefore
are indistinguishable. In a case of \astar
using tie-breaking with $h$ (sorting strategy $[f,h,*]$), the plateaus are denoted as
$\plateau{f,h}$, the set of nodes with the same $f$ cost and the same $h$ cost.
We can also refer to a specific plateau with $f=f_p$ and $h=h_p$ by $\plateau{f_p,h_p}$.

An \emph{entrance} to a $\plateau{\text{criterion}\ldots}=P$ is
a node $n \in P$, whose current parent is not in
$P$. The \emph{final plateau} is the plateau
containing the solution found by the search algorithm.  In \astar using
admissible heuristics, the final plateau is $\plateau{f^*}$ (without
tie-breaking), or $\plateau{f^*,0}$ (with $h$-based tie-breaking).
